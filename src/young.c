#include "young.h"

/* 静态变量*/
static uint8_t	checksum[23] = {0};
/* 静态变量*/

typedef enum {REQUEST=1, RESPONSE=2, SUCCESS=3, FAILURE=4, H3CDATA=10} EAP_Code;
typedef enum {IDENTITY=1, NOTIFICATION=2, MD5=4, AVAILABLE=20, ALLOCATED=7} EAP_Type;

size_t AppendYoungStartPkt( uint8_t EthHeader[], uint8_t *Packet )
{
	size_t packetlen = 0;
	uint8_t checksuminfo[131]=
	{0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff
	,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0x00,0x00,0x13,0x11,0x38,0x30,0x32,0x31,0x78
	,0x2e,0x65,0x78,0x65,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
	,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x33,0x37,0x35,0x30,0x30
	,0x00,0x00,0x13,0x11,0x00,0x28,0x1a,0x28,0x00,0x00,0x13,0x11,0x17,0x22,0x91,0x62
	,0x61,0x65,0x61,0x65,0x61,0x69,0x63,0x68,0x95,0x69,0x66,0x94,0x94,0x63,0x95,0x60
	,0x68,0x94,0x68,0x94,0x68,0x63,0x96,0x91,0x61,0x9a,0xa7,0x94,0x9f,0xab,0x00,0x00
	,0x13,0x11,0x18,0x06,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
	,0x00,0x00,0x00};
	memcpy(checksuminfo, checksum,23);
	// Fill Ethernet header
	memcpy(Packet, EthHeader,14);

	// EAPOL (4 Bytes)
	Packet[14] = 0x01;	// Version=1
	Packet[15] = 0x01;	// Type=Start
	Packet[16] = 0x00;// Length=0x0000
	Packet[17] = 0x00;

	for(packetlen=18;packetlen<=148;packetlen++)
	Packet[packetlen] =checksuminfo[packetlen-18];// Length=0x0000

	PrintDebugInfo(	"Start", Packet, packetlen);

	return packetlen;
}

size_t AppendYoungResponseIdentity(const uint8_t request[],uint8_t EthHeader[], unsigned char ipaddrinfo[], unsigned char *UserName, uint8_t *Packet)
{
	size_t packetlen = 0;
	size_t userlen = strlen(UserName);
	size_t iplen = strlen(ipaddrinfo);
	uint8_t checksuminfo[131]=
	{0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff
	,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0x00,0x00,0x13,0x11,0x38,0x30,0x32,0x31,0x78
	,0x2e,0x65,0x78,0x65,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
	,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x33,0x37,0x35,0x30,0x30
	,0x00,0x00,0x13,0x11,0x00,0x28,0x1a,0x28,0x00,0x00,0x13,0x11,0x17,0x22,0x91,0x62
	,0x61,0x65,0x61,0x65,0x61,0x69,0x63,0x68,0x95,0x69,0x66,0x94,0x94,0x63,0x95,0x60
	,0x68,0x94,0x68,0x94,0x68,0x63,0x96,0x91,0x61,0x9a,0xa7,0x94,0x9f,0xab,0x00,0x00
	,0x13,0x11,0x18,0x06,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
	,0x00,0x00,0x00};
	memcpy(checksuminfo, checksum,23);
	uint8_t ipinfo[100]=
	{0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0x23,0xff,0xff
	,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0x23,0x32,0x2e,0x31
	,0x2e,0x33,0x23,0x45,0x58,0x54,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
	,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
	,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
	,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
	,0x00,0x00,0x00,0x00};
	memcpy(ipinfo, UserName, userlen);
	ipinfo[userlen]=0x23;
	ipinfo[1+userlen]=0x30;
	memcpy(ipinfo+2+userlen, ipaddrinfo, iplen);
	ipinfo[2+userlen+iplen]=0x23;
	ipinfo[3+userlen+iplen]=0x32;
	ipinfo[4+userlen+iplen]=0x2e;
	ipinfo[5+userlen+iplen]=0x31;
	ipinfo[6+userlen+iplen]=0x2e;
	ipinfo[7+userlen+iplen]=0x33;
	uint16_t eaplen;
	// Fill Ethernet header
	memcpy(Packet, EthHeader, 14);
	// 802,1X Authentication
	Packet[14] = 0x1;	// 802.1X Version 1
	Packet[15] = 0x0;	// Type=0 (EAP Packet)
	//Packet[16~17]留空	// Length
	// Extensible Authentication Protocol
	Packet[18] = /*(EAP_Code)*/ RESPONSE;	// Code
	Packet[19] = request[19];		// ID
	//Packet[20~21]留空			// Length
	Packet[22] = /*(EAP_Type)*/ IDENTITY;	// Type
	// Type-Data
	packetlen = 23;
	for(packetlen=23;packetlen<=30+userlen+iplen;packetlen++)
	{
		Packet[packetlen] =ipinfo[packetlen-23];
	}
	for(packetlen=31+userlen+iplen;packetlen<=162+userlen+iplen;packetlen++)
	{
		Packet[packetlen] =checksuminfo[packetlen-31-userlen-iplen];
	}
	// 减掉循环多加的1
	packetlen--;
	// 补填前面留空的两处Length
	eaplen = htons(13+userlen+iplen);
	memcpy(Packet+16, &eaplen, sizeof(eaplen));// Length
	memcpy(Packet+20, &eaplen, sizeof(eaplen));// Length

	PrintDebugInfo(	"Identity", Packet, packetlen);
	return packetlen;
}

size_t AppendYoungResponseMD5(const uint8_t request[],uint8_t EthHeader[], unsigned char ipaddrinfo[], unsigned char *UserName, unsigned char *Password, uint8_t *Packet)
{
	size_t packetlen = 0;
	size_t userlen = strlen(UserName);
	size_t iplen = strlen(ipaddrinfo);
	uint8_t checksuminfo[131]=
	{0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff
	,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0x00,0x00,0x13,0x11,0x38,0x30,0x32,0x31,0x78
	,0x2e,0x65,0x78,0x65,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
	,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x33,0x37,0x35,0x30,0x30
	,0x00,0x00,0x13,0x11,0x00,0x28,0x1a,0x28,0x00,0x00,0x13,0x11,0x17,0x22,0x91,0x62
	,0x61,0x65,0x61,0x65,0x61,0x69,0x63,0x68,0x95,0x69,0x66,0x94,0x94,0x63,0x95,0x60
	,0x68,0x94,0x68,0x94,0x68,0x63,0x96,0x91,0x61,0x9a,0xa7,0x94,0x9f,0xab,0x00,0x00
	,0x13,0x11,0x18,0x06,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
	,0x00,0x00,0x00};
	memcpy(checksuminfo, checksum,23);
	uint8_t md5info[100]=
	{0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff
	,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0x23,0xff,0xff
	,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0x23,0x32,0x2e,0x31
	,0x2e,0x33,0x23,0x45,0x58,0x54,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
	,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
	,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
	,0x00,0x00,0x00,0x00};
	int k=0;
	memcpy(md5info, Password, 16);
	if(strlen(Password)<=16)
	{
		for(k=strlen(Password);k<=15;k++)
		{
			md5info[k] = 0x0;
		}
	}
	memcpy(md5info+16, UserName, userlen);
	md5info[17+userlen]=0x23;
	md5info[18+userlen]=0x30;
	memcpy(md5info+19+userlen, ipaddrinfo, iplen);
	md5info[19+userlen+iplen]=0x23;
	md5info[20+userlen+iplen]=0x32;
	md5info[21+userlen+iplen]=0x2e;
	md5info[22+userlen+iplen]=0x31;
	md5info[23+userlen+iplen]=0x2e;
	md5info[24+userlen+iplen]=0x33;
	md5info[25+userlen+iplen]=0x23;
	md5info[26+userlen+iplen]=0x45;
	md5info[27+userlen+iplen]=0x58;
	md5info[28+userlen+iplen]=0x54;
	md5info[16+userlen]=md5info[34+userlen];
	uint16_t eaplen;
	// Fill Ethernet header
	memcpy(Packet, EthHeader, 14);
	// 802,1X Authentication
	Packet[14] = 0x1;	// 802.1X Version 1
	Packet[15] = 0x0;	// Type=0 (EAP Packet)
	//Packet[16~17]留空	// Length

	Packet[18] = /*(EAP_Code)*/ RESPONSE;// Code
	Packet[19] = request[19];		// ID
	//Packet[20~21]留空

	Packet[22] = /*(EAP_Type)*/ MD5;	// Type
	Packet[23] = 16;		// Value-Size: 16 Bytes
	for(packetlen=24;packetlen<=52+userlen+iplen;packetlen++)
	{
		Packet[packetlen] =md5info[packetlen-24];
	}
	for(;packetlen<=184+userlen+iplen;packetlen++)
	{
		Packet[packetlen] =checksuminfo[packetlen-53-userlen-iplen];
	}
	// 减掉循环多加的1
	packetlen--;
	
	eaplen =htons(35+userlen+iplen);
	memcpy(Packet+16, &eaplen, sizeof(eaplen));// Length
	memcpy(Packet+20, &eaplen, sizeof(eaplen));// Length

	PrintDebugInfo(	"MD5", Packet, packetlen);
	return packetlen;
}

size_t AppendYoungLogoffPkt(uint8_t EthHeader[], uint8_t *Packet)
{
	size_t packetlen = 0;
	uint8_t checksuminfo[131]=
	{0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff
	,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0x00,0x00,0x13,0x11,0x38,0x30,0x32,0x31,0x78
	,0x2e,0x65,0x78,0x65,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
	,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x33,0x37,0x35,0x30,0x30
	,0x00,0x00,0x13,0x11,0x00,0x28,0x1a,0x28,0x00,0x00,0x13,0x11,0x17,0x22,0x91,0x62
	,0x61,0x65,0x61,0x65,0x61,0x69,0x63,0x68,0x95,0x69,0x66,0x94,0x94,0x63,0x95,0x60
	,0x68,0x94,0x68,0x94,0x68,0x63,0x96,0x91,0x61,0x9a,0xa7,0x94,0x9f,0xab,0x00,0x00
	,0x13,0x11,0x18,0x06,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
	,0x00,0x00,0x00};
	memcpy(checksuminfo, checksum,23);
	// Ethernet Header (14 Bytes)
	memcpy(Packet, EthHeader, 14);
	// EAPOL (4 Bytes)
	Packet[14] = 0x01;	// Version=1
	Packet[15] = 0x02;	// Type=Logoff
	Packet[16] = 0x00;// Length=0x0000
	Packet[17] = 0x00;
	for(packetlen=18;packetlen<=148;packetlen++)
	{
		Packet[packetlen] =checksuminfo[packetlen-18];// Length=0x0000
	}
	// 减掉循环多加的1
	packetlen--;
	PrintDebugInfo(	"Logoff", Packet, packetlen);
	return packetlen;
}


unsigned char encode(unsigned char base)   
{
	unsigned char result = 0;
	int i;
	for (i=0; i<8; i++)
	{
		result <<= 1;
		result |= base&0x01;
		base >>= 1;
	}
	return ~result;
}

void checkSum(unsigned char *buf)
{
	unsigned char table[] =
	{
		0x00,0x00,0x21,0x10,0x42,0x20,0x63,0x30,0x84,0x40,0xA5,0x50,0xC6,0x60,0xE7,0x70,
		0x08,0x81,0x29,0x91,0x4A,0xA1,0x6B,0xB1,0x8C,0xC1,0xAD,0xD1,0xCE,0xE1,0xEF,0xF1,
		0x31,0x12,0x10,0x02,0x73,0x32,0x52,0x22,0xB5,0x52,0x94,0x42,0xF7,0x72,0xD6,0x62,
		0x39,0x93,0x18,0x83,0x7B,0xB3,0x5A,0xA3,0xBD,0xD3,0x9C,0xC3,0xFF,0xF3,0xDE,0xE3,
		0x62,0x24,0x43,0x34,0x20,0x04,0x01,0x14,0xE6,0x64,0xC7,0x74,0xA4,0x44,0x85,0x54,
		0x6A,0xA5,0x4B,0xB5,0x28,0x85,0x09,0x95,0xEE,0xE5,0xCF,0xF5,0xAC,0xC5,0x8D,0xD5,
		0x53,0x36,0x72,0x26,0x11,0x16,0x30,0x06,0xD7,0x76,0xF6,0x66,0x95,0x56,0xB4,0x46,
		0x5B,0xB7,0x7A,0xA7,0x19,0x97,0x38,0x87,0xDF,0xF7,0xFE,0xE7,0x9D,0xD7,0xBC,0xC7,
		0xC4,0x48,0xE5,0x58,0x86,0x68,0xA7,0x78,0x40,0x08,0x61,0x18,0x02,0x28,0x23,0x38,
		0xCC,0xC9,0xED,0xD9,0x8E,0xE9,0xAF,0xF9,0x48,0x89,0x69,0x99,0x0A,0xA9,0x2B,0xB9,
		0xF5,0x5A,0xD4,0x4A,0xB7,0x7A,0x96,0x6A,0x71,0x1A,0x50,0x0A,0x33,0x3A,0x12,0x2A,
		0xFD,0xDB,0xDC,0xCB,0xBF,0xFB,0x9E,0xEB,0x79,0x9B,0x58,0x8B,0x3B,0xBB,0x1A,0xAB,
		0xA6,0x6C,0x87,0x7C,0xE4,0x4C,0xC5,0x5C,0x22,0x2C,0x03,0x3C,0x60,0x0C,0x41,0x1C,
		0xAE,0xED,0x8F,0xFD,0xEC,0xCD,0xCD,0xDD,0x2A,0xAD,0x0B,0xBD,0x68,0x8D,0x49,0x9D,
		0x97,0x7E,0xB6,0x6E,0xD5,0x5E,0xF4,0x4E,0x13,0x3E,0x32,0x2E,0x51,0x1E,0x70,0x0E,
		0x9F,0xFF,0xBE,0xEF,0xDD,0xDF,0xFC,0xCF,0x1B,0xBF,0x3A,0xAF,0x59,0x9F,0x78,0x8F,
		0x88,0x91,0xA9,0x81,0xCA,0xB1,0xEB,0xA1,0x0C,0xD1,0x2D,0xC1,0x4E,0xF1,0x6F,0xE1,
		0x80,0x10,0xA1,0x00,0xC2,0x30,0xE3,0x20,0x04,0x50,0x25,0x40,0x46,0x70,0x67,0x60,
		0xB9,0x83,0x98,0x93,0xFB,0xA3,0xDA,0xB3,0x3D,0xC3,0x1C,0xD3,0x7F,0xE3,0x5E,0xF3,
		0xB1,0x02,0x90,0x12,0xF3,0x22,0xD2,0x32,0x35,0x42,0x14,0x52,0x77,0x62,0x56,0x72,
		0xEA,0xB5,0xCB,0xA5,0xA8,0x95,0x89,0x85,0x6E,0xF5,0x4F,0xE5,0x2C,0xD5,0x0D,0xC5,
		0xE2,0x34,0xC3,0x24,0xA0,0x14,0x81,0x04,0x66,0x74,0x47,0x64,0x24,0x54,0x05,0x44,
		0xDB,0xA7,0xFA,0xB7,0x99,0x87,0xB8,0x97,0x5F,0xE7,0x7E,0xF7,0x1D,0xC7,0x3C,0xD7,
		0xD3,0x26,0xF2,0x36,0x91,0x06,0xB0,0x16,0x57,0x66,0x76,0x76,0x15,0x46,0x34,0x56,
		0x4C,0xD9,0x6D,0xC9,0x0E,0xF9,0x2F,0xE9,0xC8,0x99,0xE9,0x89,0x8A,0xB9,0xAB,0xA9,
		0x44,0x58,0x65,0x48,0x06,0x78,0x27,0x68,0xC0,0x18,0xE1,0x08,0x82,0x38,0xA3,0x28,
		0x7D,0xCB,0x5C,0xDB,0x3F,0xEB,0x1E,0xFB,0xF9,0x8B,0xD8,0x9B,0xBB,0xAB,0x9A,0xBB,
		0x75,0x4A,0x54,0x5A,0x37,0x6A,0x16,0x7A,0xF1,0x0A,0xD0,0x1A,0xB3,0x2A,0x92,0x3A,
		0x2E,0xFD,0x0F,0xED,0x6C,0xDD,0x4D,0xCD,0xAA,0xBD,0x8B,0xAD,0xE8,0x9D,0xC9,0x8D,
		0x26,0x7C,0x07,0x6C,0x64,0x5C,0x45,0x4C,0xA2,0x3C,0x83,0x2C,0xE0,0x1C,0xC1,0x0C,
		0x1F,0xEF,0x3E,0xFF,0x5D,0xCF,0x7C,0xDF,0x9B,0xAF,0xBA,0xBF,0xD9,0x8F,0xF8,0x9F,
		0x17,0x6E,0x36,0x7E,0x55,0x4E,0x74,0x5E,0x93,0x2E,0xB2,0x3E,0xD1,0x0E,0xF0,0x1E
	};
	unsigned char *check = buf + 0x15;
	int i, index;
	for (i=0; i<0x15; i++)
	{
		index = check[0] ^ buf[i];
		check[0] = check[1] ^ table[index*2+1];
		check[1] = table[index*2];
	}
	for (i=0; i<0x17; i++)
	{
		buf[i] = encode(buf[i]);
	}
}

void InitCheckSumForYoung()
{
	uint8_t ip[4]= {0};
	uint8_t mask[4]= {0};
	uint8_t gateway[4]= {0};
	uint8_t dns[4]= {0};
	GetWanIpFromDevice(ip);
	GetWanNetMaskFromDevice(mask);
	GetWanGatewayFromDevice(gateway);
	GetWanDnsFromDevice(dns);
	
	unsigned char  checkinfo[23] = {0};
	checkinfo[0]=0x00;
	checkinfo[1]=0x00;
	checkinfo[2]=0x13;
	checkinfo[3]=0x11;
	checkinfo[4]=0x00;
	memcpy(checkinfo+5, ip, 4);
	memcpy(checkinfo+9, mask, 4);
	memcpy(checkinfo+13, gateway, 4);
	memcpy(checkinfo+17, dns, 4);
	checkSum(checkinfo);
	memcpy(checksum, checkinfo, 23);
}
